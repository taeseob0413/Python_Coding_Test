"""
DP(Dynamic Programming)은 메모리 공간을 약간 더 사용하여 연산 속도를 비약적으로 증가시키는 방법. 동적 계획법이라고 표현하기도 한다.
DP를 사용하기 위해서는 두가지 조건 필요
1. 큰 문제를 작은 문제로 나눌 수 있음.
2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일.

탑다운과 보텀업 방식 두 가지가 가능 + 메모이제이션 기법 사용

동적 계획법 설명시 대표적으로 사용되는 예시 : 피보나치 수열

만약 첫번째 경우와 같이 피보나치를 재귀적으로만 구현할 경우에는 O(2^n) 시간복잡도를 갖으므로 시간초과의 확률이 매우 높다.
이는 중복으로 호출되는 함수가 많기 때문 >> 한번 사용된 결과값을 저장하고 다시 사용(메모이제이션)
메모이제이션 : 한 번 구현한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 갖고오는 기법(캐싱)

두번째 방식과 같이 DP로 구현을 하게 되면 O(N)의 시간 복잡도를 갖는다.
"""

#1. 피보나치 수열을 재귀함수로 구현한 경우
def fibo_reculsive(n):
    if n<=2:
        return 1
    return fibo_reculsive(n-1)+fibo_reculsive(n-2)

print(fibo_reculsive(6))

#2. 피보나치 수열을 탑다운 방식으로 구현
d=[0]*100
def fibo_dp_top_down(n):
    if n<=2:
        return 1
    if d[n] !=0:
        return d[n]
    d[n]=fibo_dp_top_down(n-1)+fibo_dp_top_down(n-2)
    return d[n]

