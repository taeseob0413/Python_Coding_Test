### 다이나믹 프로그래밍

- DP는 최적의 해를 구하는 문제에서 메모리 공간을 사용하여 연산 속도를 높이는 알고리즘
- 탑다운 & 보텀업 방식이 존재하고 메모이제이션 기법을 사용

Memoization : 한 번의 구현결과를 메모리 공간에 저장 후 같은 식이 도출될 시 메모한 결과를 갖고 오는 기법
보텀업 방식의 경우에는 dp테이블을 작성하여 저장.

- 한 예로 피보나치 수열을 들 수 있음.

피보나치 수열의 경우에 재귀함수로 구현할 경우 O(2^N)의 시간복잡도를 갖지만 DP로 구현할 시 O(N)의 시간복잡도를 갖음

```python : fibo.py

#재귀 함수를 이용한 fibo
def fibo(n):
    if n<=2:
        return 1
    return fibo(n-1)+fibo(n-2)

#dp 탑다운
dp=[0]*(101)
def dp_top_down(n):
    if n<=2:
        return 1
    if dp[n]!=0:
        return dp[n]
    dp[n]=dp_top_down(n-1)+dp_top_down(n-2)
    return dp[n]

#dp 보텀업
dp1=[0]*(101)
dp1[1],dp[2]=1,1
n=99
for i in range(3,n+1):
    dp1[i]=dp1[i-1]+dp1[i-2]

```

- 분할 정복 알고리즘 vs DP

분할 정복 알고리즘의 경우에는 DP처럼 문제들이 서로 영향을 끼치지 않고 정보를 저장하는 메모이제이션 기법도 사용하지 않음.
ex)퀵 정렬에서는 pivot 위치가 정해지면 더 이상 그 pivot값을 다시 처리하는 문제는 나오지 않음.

- 코딩테스트에서는 먼저 DP알고리즘으로 풀 수 있는 문제인지 확인하는 것이 중요!!
완전 탐색 알고리즘으로 접근 시 시간이 오래 걸리거나 해결하고자 하는 부분 문제들이 중복이 된다면 DP알고리즘으로 풀 수 있음.
탑타운 방식에서는 재귀함수적으로 접근을 하는데 이때 재귀 깊이 제한을 연장하는 방법 : sys.setrecurtionlimit()메서드 사용
